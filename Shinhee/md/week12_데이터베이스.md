> index
> 

---

# 📌 SQL 기본 쿼리문(JOIN)

---

> JOIN이란?
> 

---

<aside>
💡 2개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색/조회하는 방법

</aside>

- (2개의 테이블의 조건) 적어도 하나의 컬럼을 공유하고 있어야 한다.
- `연산자`, `From절`의 JOIN 형태에 따라 4가지로 나뉘어진다.
    - 연산자에 따른 분류
        - EQUI JOIN
        - Non-EQUI JOIN
    - From절의 JOIN 형태에 따라
        - INNER JOIN
        - OUTER JOIN

### 🤜 EQUI JOIN

- `=` 연산자를 사용

```sql
select 테이블명2.속성명
from 테이블명1, 테이블명2..
where 테이블명1.속성명 = 테이블명2.속성명
and 테이블명1.속성명 = 110
```

### 🤜 Non-EQUI JOIN

- `BETWEEN AND`, `IS NULL`, `IS NOT NULL`, `NOT IN`, `<`, `>`, `>=`, `<=` 연산자를 사용한다.

```sql
SELECT [테이블명1.]속성명, [테이블명2.]속성명 ....
FROM 테이블명1, 테이블명2..
WHERE (NON EQUI JOIN 조건)
```

### 🤜 INNER JOIN

- 테이블 간의 교집합과 같다고 보면 된다.

### 🤜 LEFT OUTER JOIN

- JOIN 수행 시 `왼쪽`에 표기된 테이블은 JOIN 조건에 일치하지 않는 값까지 모두 조회된다.
- 즉, 왼쪽 테이블에는 있고 오른쪽 테이블에는 없는 경우도 오른쪽 테이블 값은 null로 출력해서 같이 출력한다는 뜻!

```sql
-- 방법1 [MySQL]
SELECT [테이블명1.]속성명, [테이블명2.]속성명 ....
FROM 테이블명1  LEFT OUTER JOIN   테이블명2..
ON 테이블명1.속성명 = 테이블명2.속성명
 
-- 방법2 [Oracle]
SELECT [테이블명1.]속성명, [테이블명2.]속성명 ....
FROM 테이블명1, 테이블명2
WHERE 테이블명1.속성명 = 테이블명2.속성명(+)
```

### 🤜 RIGHT OUTER JOIN

 JOIN 수행 시 `오른쪽`에 표기된 테이블은 JOIN 조건에 일치하지 않는 값까지 모두 조회된다.

- 즉, 오른쪽 테이블에는 있고 왼쪽 테이블에는 없는 경우도 왼쪽 테이블 값은 null로 출력해서 같이 출력한다는 뜻!

```sql
-- 방법1 [MySQL]
SELECT [테이블명1.]속성명, [테이블명2.]속성명 ....
FROM 테이블명1  RIGHT  OUTER JOIN   테이블명2..
ON 테이블명1.속성명 = 테이블명2.속성명
 
-- 방법2 [Oracle]
SELECT [테이블명1.]속성명, [테이블명2.]속성명 ....
FROM 테이블명1, 테이블명2
WHERE 테이블명1.속성명(+) = 테이블명2.속성명
```

### 🤜 FULL OUTER JOIN

- 조인 수행 시 왼쪽, 오른쪽 테이블의 모든 값을 읽어 JOIN을 수행한다.
- `LEFT OUTER JOIN`과 `RIGHT OUTER JOIN`의 결과를 합집합으로 처리한 결과와 동일하다.

```sql
SELECT [테이블명1.]속성명, [테이블명2.]속성명 ....
FROM 테이블명1  FULL  OUTER JOIN   테이블명2..
ON 테이블명1.속성명 = 테이블명2.속성명
```

# 📌 데이터 무결성

---

## 🤜 **데이터 무결성**

데이터 무결성은 데이터의 **정확성, 일관성, 유효성**이 유지되는 것을 의미합니다. 여기서 정확성이란 중복이나 누락이 없는 상태를 뜻하고, 일관성은 원인과 결과의 의미가 연속적으로 보장되어 변하지 않는 상태를 뜻합니다.

만약 데이터베이스에서 데이터 무결성 설계를 하지 않는다면 테이블에 중복된 데이터 존재, 부모와 자식 데이터 간의 논리적 관계 깨짐, 잦은 에러와 재개발 비용 발생 등과 같은 문제가 발생할 것입니다.

그렇기 때문에 DBMS에서 데이터의 무결성이 유지되는 것은 중요한 사항이며, 주로 데이터에 적용되는 연산에 제한을 두어 데이터의 무결성을 유지합니다.

## 🤜 **데이터 무결성 제약조건의 종류와 개념**

### **1. 개체 무결성(Entity integrity)**

<aside>
💡 `**기본 키 제약**`이라고도 하며, 기본 키로 선택된 필드는 빈 값을 허용하지 않는다.

</aside>

- 기본 키(Primary Key)에는 Null 값이 올 수 없음
- 기본 키는 테이블 내에 오직 하나의 값만 존재해야 함 (하나의 테이블 내에 동일한 기본 키를 가진 레코드는 존재할 수 없음)

*기본 키란? → 테이블에서 특정 레코드를 구별하기 위해 후보 키 중에서 선택된 고유한 식별자 키*

### **2. 참조 무결성(Referential integrity)**

<aside>
💡 `**외래 키 제약**`이라고도 하며, 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야한다.

</aside>

- 외래 키(Foreign Key)의 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 함
- 외래 키 속성은 참조할 수 없는 값을 지닐 수 없음(즉, 외래 키 속성 값이 상위 테이블의 인스턴스에 반드시 존재하거나 Null이어야 함)

*외래 키란?한 테이블의 키 중에서 다른 테이블의 레코드를 유일하게 식별할 수 있는 키*

### **3. 도메인 무결성(Domain integrity)**

<aside>
💡 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 필드의 타입, Null 값 허용 등에 대한 사항을 정의하고 올바른 데이터가 입력되었는지 확인하는 조건

</aside>

예를 들어 주민등록번호 필드에 문자가 입력되는 경우엔 도메인의 무결성이 깨졌다고 볼 수 있음

### **4. Null 무결성(Null integrity)**

<aside>
💡 테이블의 특정 속성 값을 Null이 될 수 없도록 제한했다면 해당 속성에 Null이 있으면 안된다.

</aside>

### **5. 고유 무결성 (Unique integrity)**

<aside>
💡 테이블의 특정 속성에 대해 각 레코드들이 갖는 값들이 서로 달라야 하는 조건

</aside>

- 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가진다.

### **6. 키 무결성 (Key integrity)**

<aside>
💡 하나의 테이블에는 적어도 하나의 키가 존재해야 하는 조건

</aside>

### **7. 관계 무결성 (Relationship integrity)**

테이블의 어느 한 레코드의 삽입 가능 여부 또는 한 테이블과 다른 테이블의 레코드들 사이의 관계에 대한 적절성 여부를 지정한 조건

## 🤜 **무결성 제약조건의 장단점**

### 👍 **장점**

스키마를 정의할 때 일관성 조건을 오직 한 번만 명시하고, 데이터베이스가 갱신될 때 DBMS가 자동적으로 일관성 조건을 검사하므로 응용 프로그램들은 일관성 조건을 검사할 필요가 없음

### 👎 **단점**

- 프로그래밍 작업이 훨씬 복잡해진다.
- 무결성 제약조건을 반복해서 구현해야한다.
- 무결성 제약조건들 간에 서로 충돌이 발생할 수 있음

# 📌 제약조건 PK, FK, UK

---

## 🤜 PK (Primary Key)

- 해당 컬럼 값은 반드시 존재해야 하며, 유일해야 한다. (`NOT NULL` + `UNIQUE`)
- 테이블에 대한 기본키를 생성한다.
- 기본키는 테이블 당 하나만 존재하며 반드시 하나의 컬럼으로만 구성되는 것은 아니다.
- 고유 인덱스 자동 생성합니다.

## 🤜 UK (Unique Key)

- 테이블내에서 해당 컬럼 값은 항상 유일해야 한다.
- PRIMARY KEY(PK)와 유사하나 중복값을 허용, 여러개의 NULL값을 허용합니다.
- 내부적으로 고유 인덱스를 자동 생성합니다.
- 테이블 내에서 UK는 여러번 지정 가능하다.

## 👀 **기본키(Primary Key) vs 유일키(Unique Key)**

|  | 기본키 | 유일키 |
| --- | --- | --- |
| NULL 허용 | X | O |
| 인덱스 생성 | 클러스터형 인덱스 | 비클러스터형 인덱스 |
| 개수 | 테이블당 하나
(헷갈리지 말아야할것 기본키는 여러개의 칼럼을 가질 수 있고 그게 “하나”의 기본 키) | 테이블당 여러개 |
| (공통점) | 고유인덱스 자동생성 | 고유인덱스 자동생성 |

## 🤜 FK (Foriegn Key)

<aside>
💡 외부 식별자키로 테이블 간의 관계를 의미

</aside>

- 해당 컬럼 값은 참조되는 테이블의 컬럼 값 중의 하나와 일치하거나 NULL을 가진다.
- 참조하고자 하는 컬럼이 PRIMARY KEY(PK) 또는 UNIQUE KEY가 잡혀있어야 사용 가능하다.
- 부모 테이블을 삭제하기 위해서는 자식 테이블을 먼저 삭제해야한다. → 테이블 간의 잘못된 배핑을 방지하는 역할도 합니다.

> ref
> 

---

> 데이터 무결성
> 

[[Database] 데이터 무결성(Data Integrity)이란?](https://cocoon1787.tistory.com/778)

[CS-Study/JOIN.md at main · Songwonseok/CS-Study](https://github.com/Songwonseok/CS-Study/blob/main/Database/JOIN.md)

> join
> 

[Tech-Stack/SQL_Join.md at master · HyeminNoh/Tech-Stack](https://github.com/HyeminNoh/Tech-Stack/blob/master/docs/Database/SQL_Join.md)