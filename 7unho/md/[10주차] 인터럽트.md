# [10주차] 인터럽트

날짜: 2022년 10월 2일
진행상황: Done
태그: OS

---

# 인터럽트

---

<aside>
💡 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우, 현재 실행중인 작업을 중단하고 발생된 상황을 처리한 후, 다시 실행중인 작업으로 복귀하는 것

</aside>

- 사전적인 의미로는 **방해하다, 중단시키다** 라는 뜻을 가진다.
- OS적인 의미로는 **CPU의 정상적인 프로그램 실행을 방해했다** 는 의미를 가진다.
- 인터럽트의 활용
    
    ---
    
    ```python
    OS는 서로 다른 일을 하는 수많은 하드웨어를 사용한다. 이런 장치들은 동기적으로 구동되는데,
    이는 각각 동작이 완료될 때 까지 기다려야 하므로 "아무것도 하지 않으면서 바쁜 상태"로 많은
    시간을 소비하게 된다. 
    -> 인터럽트를 활용하여 **한번에 하나의 명령만 수행할 수 있는 CPU의 한계성을 보완**할 수 있다
    ```
    

## 인터럽트의 종류

---

### [1]. 외부 인터럽트

---

<aside>
💡 CPU 코어 **외부에서 어떤 일이 발생한 것을 전기적인 신호로 CPU에게 통지**하는 경우

</aside>

- **`정전•전원이상 인터럽트`** : 정전 또는 전원공급의 이상으로 인한 인터럽트
- **`기계고장 인터럽트`** : CPU 및 기타 하드웨어의 오류로 인한 인터럽트
- **`외부 인터럽트`** : Timer 나 Operator 로 인한 인터럽트
- **`입출력 인터럽트`** : 입출력의 종료나 입출력의 오류로 인한 인터럽트

### [2]. 내부 인터럽트

---

<aside>
💡 CPU 코어 외부에서 인터럽트를 거는 경우가 일반적이지만, CPU 내부에서 실행하면서 인터럽트에 걸리는 경우

</aside>

- `**프로그램 검사 인터럽트**` : Divide by Zero, Overflow/underflow 등

### [3]. 소프트웨어 인터럽트 ( = Trap )

---

<aside>
💡 사용자가 프로그램을 실행시키거나 `**Supervisor(=OS)**`를 호출하는 동작을 수행하는 경우

</aside>

- `**SVC( SuperVisor Call )**` : OS를 호출하는 동작을 수행하는 경우

## 인터럽트 동작순서

---

### [1]. 인터럽트 처리 과정

---

<aside>
💡 요청 → 중단 → 보관 → 처리 → 재개

</aside>

- **처리 과정**
    
    ---
    
    **1. 인터럽트 요청
    2. 프로그램 실행 중단**
    	 - 현재 실행중이던 `**Micro Operation**` 까지 수행
    **3. 현재 실행중인 프로그램 상태 보관**
    	 - `**Interrupt Vector**` 를 읽어 **`ISR`** 주소값을 얻음
    	 - `**ISR**`로 점프 ( 이 때, PC 값은 자동 대피 저장됨 )
    	 - 현재 진행중인 프로그램의 레지스터를 대피함
    **4. 인터럽트 서비스 루틴 처리**
    	 - 인터럽트 원인을 파악하고 실질적인 작업 수행
    	 - 서비스 루틴 수행 중, 우선순위가 더 높은 인터럽트가 발생하면 재귀적으로 1~5 반복
    **5. 상태 복구**
    	 - 해당 작업을 다 처리하면, 대피시킨 레지스터를 복원한다
    	 - `**ISR**` 끝에 `**RETI**` 명령어에 의해 인터럽트 해제
    	 - 명령어가 실행되면, PC 값을 복원하여 이전 실행 위치로 복원
    
    - `**Micro Operation`** :
    - **`Interrupt Vector` :**
    - `**ISR**` :
    - `**RETI**` :
    

### [2]. 인터럽트 벡터 ( Interrupt Vector )

---

<aside>
💡 여러 종류의 **인터럽트에 대한 ISR의 시작 주소**

</aside>

- 인터럽트 벡터 테이블 :

주기억장치의 특정 영역에 여러 개의 인터럽트에 대한 인터럽트 벡터를 모아놓은 영역

- ❓ 인터럽트 요청이 발생했을 때 CPU가 하는 일은?
    
    𝙌. 인터럽트 소스가 무엇인지, 해당 인터럽트 ISR이 어디에 적재되어 있는지 확인한다.
    
    → 이 때, 인터럽트 벡터를 활용
    

### [3]. 인터럽트 핸들러 ( Interrupt Handler )

---

**과정**

1. `**CPU**` 에서 인터럽트가 접수되면, 해당 `**인터럽트 핸들러**` 코드의 위치를 찾고 실행에 옮긴다.
2. 실행중이던 `**레지스터**`와 `**PC**`를 보관함으로써 CPU의 상태를 보존한다.
3. 인터럽트 핸들링이 완료되면 이전의 상태로 복귀한다.

### [4]. PC ( Program Counter )

---

- CPU 내부에 있는 **레지스터 중의 하나**이다.
- **다음에 실행될 명령어의 주소를** 가지고 있어 **실행할 기계어 코드의 위치를 지정**한다.
    
    → 해당 특성으로 인해 `**명령어 포인터**`라고도 불린다.
    

### [5]. 사용자 프로그램이 I/O를 하는 과정

---

- Mode bit
    
    ---
    
    `**유저 모드(1)**` : 사용자 프로그램 수행
    
    `**커널 모드(0)**` : OS 코드 수행
    
- 처리 과정
    
    ---
    
    1. SVC → 사용자 프로그램은 OS에게 I/O 요청
    2. [[3]. 소프트웨어 인터럽트 ( = Trap )](%5B10%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%85%E1%85%A5%E1%86%B8%E1%84%90%E1%85%B3%206dbd4f15b4e043a2af4d2f83de2269e2.md)  을 사용하여 인터럽트 벡터의 특정 위치로 이동
    3. 제어권이 인터럽트 벡터가 가리키는 ISR로 이동
    4. 올바른 I/O 인지 확인 후에 실행한다.
    5. I/O 완료 시, 제어권을 SVC 다음 명령으로 이동
    
- 인터럽트와 트랩( 소프트웨어 인터럽트 )의 차이점
    
    ---
    
    인터럽트
    
    - 하드웨어적인 흐름의 변화
    - 프로그램의 외부 상황에 따라 발생 시점이 일정하지 않다 → `**비동기적**`
    
    트랩
    
    - 소프트웨어적인 흐름의 변화
    - 발생 시점이 프로그램의 일정한 지점
        
        → `**동기적**`
        

## 인터럽트 우선순위

---

<aside>
💡 **`정전•전원이상 인터럽트` →**  **`기계고장 인터럽트` → `외부 인터럽트`** → **`입출력 인터럽트`**
→  **`프로그램 검사 인터럽트`** → **`SVC(SuperVisor Call)`**

</aside>

### 우선순위 판별 방법

---

### [1]. 폴링 ( Polling )

---

<aside>
💡 가장 높은 인터럽트로부터 요청 플래그를 검사하여 `**ISR**` 을 수행하는 소프트웨어적인 방법

</aside>

- 인터럽트를 조사하는 비용이 들어 반응시간이 느리다.
- 하드웨어를 추가할 필요가 없어 회로가 간단하다

### [2]. 데이지 체인 (  Daisy Chain )

---

<aside>
💡 어디에 인터럽트가 발생하는지 확인하는 회로를 직렬로 연결한 하드웨어적인 방법

</aside>