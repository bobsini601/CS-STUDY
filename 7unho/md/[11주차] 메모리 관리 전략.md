# [11주차] 메모리 관리 전략

날짜: 2022년 10월 8일
진행상황: Done
태그: OS

---

# 메모리 관리 전략

---

## 메모리 관리 배경

---

- 각각의 프로세스는 독립된 메모리 공간을 갖고, OS 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다. 단지, **OS만이 OS 메모리 영역과 사용자 메모리 영역 접근에 제약을 받지 않는다.**

### [1]. 스와핑 ( Swapping )

---

<aside>
💡 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치로 내보내고, 다른 프로세스에 할당할 수 있다.

</aside>

- 위와 같은 과정을 swap시킨다 라고 표현한다.
- Swap 과정
    
    ---
    
    1. 주기억장치`**( RAM )**`으로 불러오는 과정을 **Swap in**
    2. 보조기억장치로 내보내는 과정을 **Swap out**
- 스왑에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 **메모리 공간이 부족할 때 스왑이 진행된다.**

### [2]. 단편화 ( Fragmentation )

---

<aside>
💡 프로세스들이 메모리에 적재되고 제거되는 일이 반복되면 메모리 틈 사이에 **사용하지 못할 만큼의 작은 자유공간이 늘어나게 되는것**

</aside>

![Untitled](../assets/week11_1_1.png)

**[2] - 1. 외부 단편화**

---

- **메모리 공간 중 사용하지 못하게 되는 일부분.**
- 물리 메모리( RAM )에서 사이사이 남는 공간들을 모두 합치면 충분히 공간이 되는 부분들이
    
    분산되어 있을 때 발생한다고 볼 수 있다.
    

**[2] - 2. 내부 단편화**

---

- **프로세스가 사용하는 메모리 공간에 포함된 남는 부분.**
- 메모리 분할 자유 공간이 100이고, 프로세스가 97만큼 사용할 때 2라는 내부 단편화가 발생한다.

### [3]. 압축

---

- 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아 자유공간을 확보하는 방법
- 작업 효율이 좋지 않다.

![Untitled](../assets/week11_1_2.png)

## 페이징 ( Paging )

---

<aside>
💡 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 관리 방법

</aside>

- 외부 단편화와 압축 작업을 해소하기 위해 생긴 방법론
- 물리 메모리는 `**Frame**` 이라는 고정 크기로 분리되어 있다
- 프로세스가 점유하는 논리 메모리는 `**페이지**` 라 불리는 고정 크기의 블록으로 분리된다.

### 페이징의 **장점**

---

1. 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고, 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있다.
2. **논리 메모리**에서 하나의 프로세스가 사용하는 공간은 **여러 개의 `페이지`로 나눠 관리되고,**
    
    개별 페이지는 순서에 상관없이 **물리 메모리에 있는 `Frame`에 매핑되어 저장**된다.
    

### 페이징의 단점

---

- 1.  내부 단편화 문제의 비중이 늘어난다.
    
    ---
    
    - 예를 들어 페이지 크기가 100이고 프로세스가 310의 메모리가 필요하다면 총 4개의 페이지 프레임이 요구된다.
        
        → 결론적으로 4번째 페이지 프레임에는 90이라는 **내부 단편화 문제가 발생**
        
    

## 세그멘테이션 ( Segmentation )

---

<aside>
💡 서로 다른 크기의 논리적 단위인 **세그먼트(Segment)** 로 분할하는 방법

</aside>

- 페이징에서는 논리 메모리와 물리 메모리를 같은 크기의 페이지로 나누었다.
- 세그멘테이션에서는 서로 다른 크기의 논리적 단위인 `**세그먼트**`로 분할한다.
- 사용자가 두 개의 주소 지정( 세그먼트 번호 + 변위 )
- 세그먼트 테이블에는 **각 세그먼트의 기준( 세그먼트의 시작 주소 )와** **한계( 세그먼트의 길이 )를 저장**

# 가상 메모리

---

<aside>
💡 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법

</aside>

## 가상 메모리 개발 배경

---

- 다중 프로그래밍을 실현하기 위해서는 실행 되는 코드의 전부를 물리 메모리에 존재시켜야 했고,
    
    메모리 용량보다 큰 프로그램은 실행시킬 수 없었다.
    
- 여러 프로그램을 동시에 메모리에 올리기에는 **용량의 한계**와 **페이지 교체 등의 성능 이슈**가 발생
- 가끔만 사용되는 코드가 차지하는 메모리들을 확인할 수 있다는 점

**→ 불필요하게 전체의 프로그램이 메모리에 올라와있지 않아도 된다라는 것을 알 수 있었다.**

### 𝙌. 프로그램의 일부만 메모리에 올릴 수 있다면?

---

1. 물리 메모리 크기에 제약받지 않게 된다.
2. 더 많은 프로그램을 동시에 실행할 수 있게 된다.
    
    `**응답시간**` 은 유지되고, `**CPU 이용률**` 과 `**처리율**` 은 높아진다.
    
3. `**SWAP**`에 필요한 입출력이 줄어든다 → 더욱 빠르게 실행된다.

## 가상 메모리의 역할

---

<aside>
💡 가상 메모리는 **실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리**한 것

→ 작은 메모리를 가지고도 얼마든지 **큰 가상 메모리 공간을 개발자에게 제공**할 수 있다.

</aside>

### [1]. 가상 주소 공간

---

<aside>
💡 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상 메모리에 구현한 공간.

</aside>

- 프로세스가 요구하는 메모리 공간을 가상메모리에서 제공함으로써 현재 직접적으로 필요치 않은 메모리 공간은 실제 메모리에 올리지 않는 것으로 물리 메모리를 절약할 수 있다.

### [2]. 프로세스간 페이지 공유

---

- 가상 메모리는 `**시스템 라이브러리**` 가 여러 프로세스들 사이에 공유될 수 있도록 한다.
    
    각 프로세스들은 `**공유 라이브러리**` 를 **자신의 주소 공간에 두고 사용하는 것처럼 인식**하지만, 라이브러리가 올라가 있는 `**물리 메모리 페이지` 들은 모든 프로세스에 공유되고 있다.**
    
- 가상 메모리는 **프로세스들의 메모리 공유를 가능하게 하고**, **공유 메모리를 통해 통신**할 수 있게 한다.
    
    이 또한, 각 프로세스들은 각자 자신의 주소 공간처럼 인식하지만, 실제 물리 메모리는 공유되고 있다.
    
- 가상 메모리는 `**fork()**` 를 통한 **프로세스 생성 과정에서 페이지들이 공유되는 것을 가능하게** 한다.

# 캐시의 지역성

---

<aside>
💡 캐시 메모리는 **장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리**이다.

</aside>

- 캐시의 성능은 작은 용량의 캐시메모리에 CPU가 이후에 참조할 정보가 어느정도 들어있냐에 따라 좌우된다. → `**Cache Hit Rate**`

## 캐시의 지역성 원리

---

- `**적중률( Hit Rate )**` 을 극대화 시키기 위해 데이터 `**지역성( Locality )의 원리**`를 사용한다.
    
    지역성의 전제 조건으로 **프로그램은 모든 코드나 데이터를 균등하게 Access하지 않는다**
    
    즉, **지역성이란** 기억장치 내의 정보를 균일하게 Access하는 것이 아닌 **어느 한 순간에 특정 부분을 집중적으로 참조하는 특성**을 뜻한다.
    

`**시간 지역성**` : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성

`**공간 지역성**` : 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성

## Caching Line

---

<aside>
💡 캐시에 데이터를 저장할 때 특정 자료구조를 사용하여 묶음으로 저장하는 것

</aside>

- `**캐시**` 가 아무리 가까이 있더라고 찾고자 하는 데이터가 어느 곳에 저장되어 있는지를 몰라 데이터를 순회한다면 시간이 오래 걸린다.
    
    즉, 캐시에 목적 데이터가 저장되어 있다면 **바로 접근하여 출력할 수 있어야 캐시가 의미 있어진다.**
    
- 프로세스는 다양한 주소에 있는 데이터를 사용하므로 빈번하게 사용하는 데이터의 주소 또한 흩어져 있다. 따라서, **캐시에 저장하는 데이터에는 데이터의 메모리 주소등을 기록해 둔 태그를 달아놓을 필요가 있다**. 이러한 **태그들의 묶음을 `캐싱 라인`**이라고 하며, 메모리로부터 가져올 때도 `**캐싱 라인`을 기준으로** 가져온다.

# 🔗   참조 링크

---

[Interview_Question_for_Beginner/OS at master · JaeYeopHan/Interview_Question_for_Beginner](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5)